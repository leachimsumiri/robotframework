#!/usr/bin/python
# Echo client program

import logging

import numpy as np
import urx
import math
from distutils.util import strtobool

def _array_to_float_helper(array):
    """
    Converts a given array to a float Array
    :param array: the given array
    :return: a float Array
    """
    array = np.array(array)
    return array.astype(np.float)


def _isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
    """ Check if to float numbers are close together (almost equal).
    :seealso: isclose of Python 3.5 https://docs.python.org/3/library/math.html
    :param a, b: Input values to be compared.
    :param rel_tol: The relative tolerance parameter as float.
    :param atol: The absolut tolerance parameter as float.

    The tolerance values are positive, typically very small numbers. 
    The relative difference (rel_tol * abs(b)) and the absolute difference abs_tol 
    are added together to compare against the absolute difference between a and b.
    """
    return (abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol))


class URLibrary:
    """
    Robot Framework Library which uses the urx Library to communicate with an UR robot.
    """

    __version__ = '0.3'

    ROBOT_LIBRARY_SCOPE = 'GLOBAL'

    _DEFAULT_ROBOT_EPSILON = 0.0001 
    """ Default repeated positioning accuracy in m."""

    def __init__(self):
        self.rob = None
        self._epsilon = URLibrary._DEFAULT_ROBOT_EPSILON
        logging.basicConfig(level=logging.DEBUG)

    @property
    def epsilon(self):
        """Repeated positioning accuracy in m."""
        return self._epsilon

    @epsilon.setter
    def epsilon(self, value):
        """Repeated positioning accuracy in m.

        :param value: Deviation in m.
        """
        self._epsilon = float(value)

    def position_is_close(self, actual, target):
        """ Check if the actual position is equal to the given target position.

        :param actual: Actual position of the robot.
        :param target: The postion to be compared against the actual position.
        """
        return _isclose(float(actual), float(target), abs_tol=self.epsilon)

    def position_is_less(self, actual, target):
        """ Check if the actual position is less than the given target position.

        :param actual: Actual position of the robot.
        :param target: The postion to be compared against the actual position.
        """
        return float(actual) < (float(target) - self.epsilon)

    def position_is_greater(self, actual, target):
        """ Check if the actual position is less than the given target position.

        :param actual: Actual position of the robot.
        :param target: The postion to be compared against the actual position.
        """
        return float(actual) > (float(target) + self.epsilon)
        
        
    def rotate_vector_2d(self, x, y, degrees):
        """ Rotate the vector in base coordinate system by given degrees in radians.

        :param x: The x component to be rotated 
        :param y: The y component to be rotated
        :param degrees: Angle in radians.
        :return: The resulting vector[x, y] as list.
        """
        vector = [x, y, degrees]
        value = _array_to_float_helper(vector)
        result = []
        result.append(value[0] * math.cos(value[2]) - value[1] * math.sin(value[2]))
        result.append(value[0] * math.sin(value[2]) + value[1] * math.cos(value[2]))
        return result

    def connect_to_robot(self, host, use_rt=False):
        """
        Establish an Ethernet Connection to the UR Robot

        :param host: The Host IP Address or Alias Name
        :param use_rt: Enables/Disables the Realtime Monitor Interface
        """
        self.rob = urx.Robot(host, use_rt)

    def get_force(self, wait=True):
        """
        Returns the force exceted at the TCP
        Return the current externally excerted force at the TCP. The force is the
        norm of Fx, Fy, and Fz calculated using get tcp force().

        :return:  The force in Newtons (float)

        if wait==True, waits for next packet before returning
        """
        return self.rob.get_force(wait=wait)

    def get_joints_position(self, wait=True):
        """
        Returns the actual angular positions of all joints
        The angular actual positions are expressed in radians and returned as a
        vector of length 6. Note that the output might differ from the output of
        get target joint positions(), especially during acceleration and heavy
        loads.

        :return:  The current actual joint angular position vector in rad : [Base,
                  Shoulder, Elbow, Wrist1, Wrist2, Wrist3]
        """
        return self.rob.getj(wait=wait)

    def get_joint_speeds(self, wait=True):
        """
        Returns the current measured TCP speed
        The speed of the TCP retuned in a pose structure. The first three values
        are the cartesian speeds along x,y,z, and the last three define the
        current rotation axis, rx,ry,rz, and the length |rz,ry,rz| defines the angular
        velocity in radians/s.

        :return:  The current actual TCP velocity vector; ([X, Y, Z, Rx, Ry, Rz])
        """
        return self.rob.speedj(wait=wait)

    def get_tcp_position(self, wait=True, _log=True):
        """
        Returns the current measured tool pose
        Returns the 6d pose representing the tool position and orientation
        specified in the base frame. The calculation of this pose is based on
        the actual robot encoder readings.

        :return: The current actual TCP vector : ([X, Y, Z, Rx, Ry, Rz])
        """
        return self.rob.getl(wait=wait, _log=_log)

    def show_popup(self, msg, title="Popup", warning=False, error=False):
        """
        Display popup on GUI
        Display message in popup window on GUI.

        :param msg: message string
        :param title: title string
        :param warning: warning message
        :param error: error message
        """
        prog = "popup(\"%s\",\"%s\",%r,%r)" % (msg, title, strtobool(warning), strtobool(error))
        self.rob.send_program(prog)

    def get_tcp_force(self, wait=True):
        """
        Returns the wrench (Force/Torque vector) at the TCP
        The external wrench is computed based on the error between the joint
        torques required to stay on the trajectory and the expected joint
        torques. The function returns "p[Fx (N), Fy(N), Fz(N), TRx (Nm), TRy (Nm),
        TRz (Nm)]". where Fx, Fy, and Fx are the forces in the axes of the robot
        base coordinate system measured in Newtons, and TRx, TRy, and TRz
        are the torques around these axes measyred in Newton times Meters.

        :return: the wrench (pose)

        if wait==True, waits for next packet before returning
        """
        return self.rob.get_tcp_force(wait=wait)

    def set_gravity(self, vector):
        """
        Set the direction of the acceleration experienced by the robot. When
        the robot mounting is fixed, this corresponds to an acceleration of g
        away from the earth's centre.
            Example: set gravity([0, 9.82*sin(theta), 9.82*cos(theta)])
        will set the acceleration for a robot that is rotated "theta" radians
        around the x-axis of the robot base coordinate system

        :param vector: 3D vector, describing the direction of the gravity, relative
                       to the base of the robot.
        """
        return self.rob.set_gravity(_array_to_float_helper(vector))

    def set_payload(self, payload, cx, cy, cz):
        """
        Set payload mass and center of gravity

        Sets the mass and center of gravity (abbr. CoG) of the payload.
        This function must be called, when the payload weight or weigh
        distribution changes significantly - I.e when the robot picks up or puts
        down a heavy workpiece.
        The CoG argument is optional - If not provided, the Tool Center Point
        (TCP) will be used as the Center of Gravity (CoG). If the CoG argument
        is omitted, later calls to set tcp(pose) will change CoG to the new TCP.
        The CoG is specified as a Vector, [CoGx, CoGy, CoGz], displacement,
        from the toolmount.

        :param payload: mass in kilograms
        :param cx: Center of Gravity in meters
        :param cy: Center of Gravity in meters
        :param cz: Center of Gravity in meters
        """
        self.rob.set_payload(payload, (float(cx), float(cy), float(cz)))

    def set_tcp(self, pose):
        """
        Set the Tool Center Point
        Sets the transformation from the output flange coordinate system to
        the TCP as a pose.

        :param pose: A pose describing the transformation.
        """
        self.rob.set_tcp(_array_to_float_helper(pose))

    def text_message(self, msg):
        """
        Send text message to log
        Send message with s1 and s2 concatenated to be shown on the GUI
        log-tab

        :param msg: message string, variables of other types (int, bool poses
                    etc.) can also be sent
        """
        msg = "\"%s\"" % msg
        self.rob.send_message(msg)

    def get_analog_in(self, nb, wait=True):
        """
        Get standard analog input signal level
        See also get tool analog in.

        :param nb: The number (id) of the input, integer: [0:1]
        :return: The signal level.
        """
        return self.rob.get_analog_in(nb, wait=wait)

    def get_analog_inputs(self, wait=True):
        """
        Get standard analog input signal level of both inputs
        See also get tool analog in.

        :return: The signal level of both inputs.
        """
        return self.rob.get_analog_inputs(wait=wait)

    def get_digital_in_bits(self):
        """
        Get standard digital input signal level
        See also get configurable digital in and get tool digital in.

        :return: The signal level.
        """
        return self.rob.get_digital_in_bits()

    def get_digital_in(self, nb, wait=True):
        """
        Get standard digital input signal level
        See also get configurable digital in and get tool digital in.

        :param nb: The number (id) of the input, integer: [0:7]
        :return: The signal level.
        """
        return self.rob.get_digital_in(nb, wait)

    def get_digital_out(self, val, wait=True):
        """
        Get standard digital output signal level
        See also get configurable digital out and get tool digital out.

        :param val: The number (id) of the input, integer: [0:7]
        :return: The signal level.
        """
        return self.rob.get_digital_out(val, wait=wait)

    def get_digital_out_bits(self, wait=True):
        """
        Get standard digital output signal level
        See also get configurable digital out and get tool digital out.

        :return: The signal level.
        """
        return self.rob.get_digital_out_bits(wait=wait)

    def set_analog_out(self, nb, val):
        """
        Set standard analog output level

        :param nb: The number (id) of the input, integer: [0:1]
        :param val: The relative signal level [0;1] (float)
        """
        self.rob.set_analog_out(nb, val)

    def set_digital_out(self, nb, val):
        """
        Set standard digital output signal level
        See also set configurable digital out and set tool digital out.

        :param nb: The number (id) of the input, integer: [0:7]
        :param val: The signal level. (boolean)
        """
        self.rob.set_digital_out(nb, strtobool(val))

    def set_tool_voltage(self, voltage):
        """
        Sets the voltage level for the power supply that delivers power to the
        connector plug in the tool flange of the robot. The votage can be 0, 12
        or 24 volts.

        :param voltage: The voltage (as an integer) at the tool connector,
                     integer: 0, 12 or 24.
        """
        self.rob.set_tool_voltage(voltage)

    def movec(self, pose_via, pose_to, acc=0.01, vel=0.01, wait=True, threshold=None):
        """
        Move Circular: Move to position (circular in tool-space)
        TCP moves on the circular arc segment from current pose, through
        pose via to pose to. Accelerates to and moves with constant tool
        speed v.

        :param pose_via: path point (note: only position is used).
                        (forward kinematics is used to calculate the corresponding pose)
        :param pose_to: target pose (forward kinematics is used to calculate the corresponding pose)
        :param acc: tool acceleration [m/s^2]
        :param vel: tool speed [m/s]
        """
        self.rob.movec(_array_to_float_helper(pose_via), _array_to_float_helper(pose_to), acc=acc, vel=vel, wait=wait,
                       threshold=threshold)


    def movej(self, pose, acc=0.01, vel=0.01, wait=True):
        """
        Move to position (linear in joint-space) When using this command, the
        robot must be at standstill or come from a movej og movel with a
        blend. The speed and acceleration parameters controls the trapezoid
        speed profile of the move.

        :param pose: joint positions (inverse kinematics is used to calculate the corresponding joint positions)
        :param acc: joint acceleration of leading axis [rad/s^2]
        :param vel: joint speed of leading axis [rad/s]
        """
        self.rob.movej(_array_to_float_helper(pose), acc=acc, vel=vel, wait=wait)

    def movel(self, pose, acc=0.01, vel=0.01, wait=True):
        """
        Move to position (linear in tool-space)
        See movej.

        :param pose: target pose (forward kinematics is used to calculate the corresponding pose)
        :param acc: tool acceleration [m/s^2]
        :param vel: tool speed [m/s]
        """
        self.rob.movel(_array_to_float_helper(pose), acc=acc, vel=vel, wait=wait)

    def movep(self, pose, acc=0.01, vel=0.01, wait=True):
        """
        Move Process
        Blend circular (in tool-space) and move linear (in tool-space) to
        position. Accelerates to and moves with constant tool speed v.

        :param pose: target pose (forward kinematics is used to calculate the corresponding pose)
        :param acc: tool acceleration [m/s^2]
        :param vel: tool speed [m/s]
        """
        self.rob.movep(_array_to_float_helper(pose), acc=acc, vel=vel, wait=wait)

    def servoc(self, pose, acc=0.01, vel=0.01, wait=True, relative=False, threshold=None):
        """
        Servo Circular
        Servo to position (circular in tool-space). Accelerates to and moves
        with constant tool speed v.

        :param pose: target pose (forward kinematics is used to calculate the corresponding pose)
        :param acc: tool acceleration [m/s^2]
        :param vel: tool speed [m/s]
        """
        return self.rob.servoc(_array_to_float_helper(pose), acc=acc, vel=vel, wait=wait, relative=relative,
                               threshold=threshold)

    def translate(self, vect, acc=0.01, vel=0.01, wait=True, command="movel"):
        """
        move tool in base coordinate, keeping orientation
        """
        self.rob.translate(_array_to_float_helper(vect), acc=acc, vel=vel, wait=wait, command=command)

    def get_pose(self):
        """
        get current transform from base to to tcp
        """
        return self.rob.get_pose()

    def set_pose(self, trans, acc=0.01, vel=0.01, wait=True, command="movel", threshold=None):
        """
        move tcp to point and orientation defined by a transformation
        UR robots have several move commands, by default movel is used but it can be changed
        using the command argument
        """
        self.rob.set_pose(_array_to_float_helper(trans), acc=acc, vel=vel, wait=wait, command=command,
                          threshold=threshold)

    def set_orientation(self, orient, acc=0.01, vel=0.01, wait=True, threshold=None):
        """
        set tool orientation using a orientation
        matric from math3d or a orientation vector
        """
        self.rob.set_orientation(_array_to_float_helper(orient), acc=acc, vel=vel, wait=wait, threshold=threshold)

    def translate_tool(self, vect, acc=0.01, vel=0.01, wait=True, threshold=None):
        """
        move tool in tool coordinate, keeping orientation
        """
        self.rob.translate_tool(_array_to_float_helper(vect), acc=acc, vel=vel, wait=wait, threshold=threshold)

    def back(self, z=0.05, acc=0.01, vel=0.01):
        """
        move in z tool
        """
        self.rob.back(z=z, acc=acc, vel=vel)

    def speedj(self, velocities, acc, min_time):
        """
        Joint speed
        Accelerate to and move with constant joint speed

        :param velocities: joint speeds [rad/s]
        :param acc: joint acceleration [rad/s^2] (of leading axis)
        :param min_time: minimal time before function returns
        """
        return self.rob.speedj(velocities, acc, min_time)

    def speedl(self, velocities, acc, min_time):
        """
        Tool speed
        Accelerate to and move with constant tool speed
        http://axiom.anu.edu.au/~roy/spatial/index.html

        :param velocities: joint speeds [rad/s]
        :param acc: joint acceleration [rad/s^2] (of leading axis)
        :param min_time: minimal time before function returns
        """
        return self.rob.speedl_tool(velocities, acc, min_time)

    def speedx(self, command, velocities, acc, min_time):
        self.rob.speedxe(command, velocities, acc, min_time)

    def movex(self, command, tpose, acc=0.01, vel=0.01, wait=True, relative=False, threshold=None):
        """
        Send a move command to the robot. since UR robotene have several methods this one
        sends whatever is defined in 'command' string
        """
        self.rob.movex(_array_to_float_helper(command), _array_to_float_helper(tpose), acc=acc, vel=vel, wait=wait,
                       relative=relative, threshold=threshold)

    def movels(self, pose_list, acc=0.01, vel=0.01, radius=0.01, wait=True, threshold=None):
        """
        Concatenate several movel commands and applies a blending radius
        pose_list is a list of pose.
        This method is useful since any new command from python
        to robot make the robot stop
        """
        self.rob.movels(_array_to_float_helper(pose_list), acc=acc, vel=vel, radius=radius, wait=wait,
                        threshold=threshold)

    def movexs(self, command, pose_list, acc=0.01, vel=0.01, radius=0.01, wait=True, threshold=None):
        """
        Concatenate several movex commands and applies a blending radius
        pose_list is a list of pose.
        This method is useful since any new command from python
        to robot make the robot stop
        """
        self.rob.movexs(command, _array_to_float_helper(pose_list), acc=acc, vel=vel, radius=radius, wait=wait,
                        threshold=threshold)

    def stopj(self, acc=1.5):
        """
        Stop (linear in joint space)
        Decellerate joint speeds to zero

        :param acc: joint acceleration [rad/s^2] (of leading axis)
        """
        self.rob.stopj(acc=acc)

    def stopl(self, acc=0.5):
        """
        Stop (linear in tool space)
        Decellerate tool speed to zero

        :param acc: tool accleration [m/s^2]
        """
        self.rob.stopl(acc=acc)

    def stop(self):
        """
        Same as StopJ but with standard parameter of acc=1.5
        """
        self.rob.stop()

    def set_freedrive(self, is_freedrive):
        """
        Enable/Disables the robot freedrive mode.
        The freedrive mode is used to move the robot around by hand
        in the same way as by pressing the "freedrive" button.
        The robot will not be able to follow a trajectory (eg. a movej) in this
        mode.
        """
        self.rob.set_freedrive(is_freedrive)

    def set_simulation(self, val=False):
        """
        Enable/Disable simulation
        :param val: True to enable, False to disable
        """
        self.rob.set_simulation(val)

    def get_realtime_monitor(self):
        """
        return a pointer to the realtime monitor object
        useful to track robot position for example
        """
        return self.rob.get_realtime_monitor()

    def up(self, z=0.05, acc=0.01, vel=0.01):
        """
        Move Robot up in z-Position keeping the Tool in x and y stable
        """
        self.rob.up(float(z), float(acc), float(vel))

    def down(self, z=0.05, acc=0.01, vel=0.01):
        """
        Move Robot down in z-Postion keeping the Tool in x and y stable
        """
        self.rob.down(float(z), float(acc), float(vel))

    def getl(self, wait=False, _log=True):
        """
        get TCP position
        """
        self.rob.getl(wait=wait, _log=_log)

    def disconnect(self):
        """
        Closes ethernet communication

        Closes down the socket connection to the server.
        """
        self.rob.close()
